language Trellis

------------
-- Tokens --
------------

token LIdent {
  repr = LIdentRepr {},
  constructor = LIdentTok,
  fragment = LIdentTokenParser,
  ty = String,
}

token UIdent {
  repr = UIdentRepr {},
  constructor = UIdentTok,
  fragment = UIdentTokenParser,
  ty = String,
}

token Integer {
  repr = IntRepr {},
  constructor = IntTok,
  fragment = UIntTokenParser,
  ty = Int,
}

token UName {
  base = UIdent,
  wrap = nameNoSym,
  ty = Name,
}
token LName {
  base = LIdent,
  wrap = nameNoSym,
  ty = Name,
}

----------------------------
-- Top-level declarations --
----------------------------

start Top

type Top
type Decl
type ConstrDecl
type AutomatonProp
type Param

prod Top: Top = d:Decl+

-- Defines a constructor declaration production.
-- Examples: 'Foo (foo, bar)', 'A'
-- Counter example: 'A ()'
prod ConstrDecl: ConstrDecl =
  vName:UIdent ("(" param:LIdent ("," param:LIdent)* ")")?

-- Defines a type declaration production.
-- Example: 'type MyType (foo, bar) {Foo (foo, bar), A, }'
prod TypeDecl : Decl =
  "type" name:UIdent ("(" param:LIdent ("," param:LIdent)* ")")?
  "{"
    (v:ConstrDecl ",")*
  "}"

-- Defines an automaton declaration
-- Example: 'automaton MyAutomaton {_, }'
prod AutomatonDecl: Decl =
  "automaton" name:UIdent
  "{"
    (prop:AutomatonProp ",")*
  "}"

-- Defines a parameter
-- Example: 'foo : _'
prod Param: Param = n:LIdent ":" ty:Type

-- Defines a function declaration.
-- Example: 'let myFun(foo:_) : _ = _'
prod FuncDecl: Decl =
  "let" fname:LIdent
  ("(" p:Param ("," p:Param)* ")")?
  (":" ty:Type)?
  "=" e:Expr

----------------------------
-- Properties in automata --
----------------------------

-- Defines a state property.
prod StateProp: AutomatonProp =
  "state" ":" ty:Type

prod SetProp: AutomatonProp =
  (name:LIdent | initial:"initial") ":" s:Set

----------
-- Sets --
----------

type Set {
  grouping = "(" ")",
}

-- Defines an infix set union operator
infix left SetUnion: Set = "\\u"

-- Defines an infix set intersection operator
infix left SetIntersection: Set = "\\n"

-- Defines a named set.
-- Example: 'mySet'
prod NamedSet: Set = name:LIdent

-- Defines a set literal. A later pass over the AST needs to check whether it is
-- a value set or a transition set, and give an error if mixed.
-- Example (value set): {1, a}
-- Example (transition set): { @ false -> true,  }
-- TODO: syntax for transition set
prod SetLit: Set =
  "{"
    ((e:Expr | "@" e:Expr "->" to:Expr) ",")*
  "}"

-- Defines a set builder. A later pass over the AST needs to check whether it is
-- a value set or a transition set builder.
-- Example (transition set builder): {{ @ x -> y | true }}
-- TODO: syntax for tr
prod SetBuilder: Set =
  "{{"
     (p:Pat | "@" p:Pat "->" to:Pat)
     "|"
     (e:Expr ",")*
   "}}"

--------------
-- Patterns --
--------------

type Pat {
  grouping = "(" ")",
}

prod ConPat: Pat = c:UIdent ("(" (p:Pat ",")+ ")")?

-- Defines a named pattern variable
-- Example: 'foo'
prod VarPat: Pat = id:LIdent

-- Defines a wildcard pattern
prod WildPat: Pat = "_"

-- Only allowed in an ArrayPat
-- TODO: why does it trigger an LL1 conflict for Con?
-- postfix DotsPat: Pat = p:Pat "..."

prod ArrayPat: Pat =
  "[" (p:Pat ",")* "]"

-- Defines a tuple pattern
-- Example '(foo, [a])'
-- TODO: syntax not ideal
prod TupPat: Pat =
  "<" p:Pat ("," p:Pat)+ ">"

-- Defines an integer pattern
-- TODO: negative integers?
prod IntPat: Pat = i:Integer

-- Defines Boolean patterns
prod TruePat: Pat = "true"
prod FalsePat: Pat = "false"

-----------------------
-- Normal data types --
-----------------------

type Type {
  grouping = "(" ")",
}

-- Defines a type application
postfix TypeApplication: Type =
  "(" a:Type ("," a2:Type)* ")"

-- Defines an array type
postfix ArrayType: Type = "[" count:Expr "]"

-- Defines a concrete type
prod ConcreteType: Type = n:UIdent

-- Defines a tuple type
-- TODO: tuple syntax
prod TupleType: Type = "<" t:Type ("," t:Type)+ ">"

-- Defines an integer type
prod IntegerType: Type =
  lb:Integer (".." ub:Integer)?

-- Defines an automaton state type
prod AutomatonState: Type = automaton:LIdent "." "state"

-----------------
-- Expressions --
-----------------

type Expr {
  grouping = "(" ")",
}

-- Operators
postfix Application: Expr =
  "(" (a:Expr ("," a2:Expr)*)? ")"
infix left Plus: Expr = "+"
infix left Minus: Expr = "-"
infix left MultipliedWith: Expr = "*"
infix left DividedBy: Expr = "/"
-- Either a nested access or a tuple access
postfix ProjectionAccess: Expr = "." (label:LIdent | index:Integer)
infix Equal: Expr = ("=" | "==")
infix NotEqual: Expr = ("/=" | "!=")
infix LessThan: Expr = "<"
infix GreaterThan: Expr = ">"
infix LessThanOrEqual: Expr = "<="
infix GreaterThanOrEqual: Expr = ">="
infix left And: Expr = "&&"
infix left Or: Expr = "||"
postfix ArrayAccess: Expr = "[" e:Expr "]"
prefix If: Expr =
  "if" c:Expr "then" e:Expr "else"
infix In: Expr = "\\in"
infix Notin: Expr = "\\notin"
infix left Union: Expr = "\\u"
infix left Intersection: Expr = "\\n"

prod Output: Expr = "output"
prod True: Expr = "true"
prod False: Expr = "false"
prod Variable: Expr = v:LName
prod Constructor: Expr = c:UName
prod Integer: Expr = i:Integer
-- May only be used inside a List
-- TODO: LL1 conflict
-- prod SubSeq: Expr = s:LIdent "..."
prod List: Expr = "[" (e:Expr ",")* "]"
-- TODO: tuple syntax
prod Tuple: Expr =
  "@<" e:Expr ("," e:Expr)+ ">@"

precedence {
  ProjectionAccess ArrayAccess Application;
  MultipliedWith DividedBy;
  Plus Minus;
  ~ Equal NotEqual LessThan GreaterThan LessThanOrEqual GreaterThanOrEqual;
  And Or;
  If;
} except {
  MultipliedWith ? DividedBy;
  And ? Or;
}

precedence {
  ~ ProjectionAccess ArrayAccess Application;
  Union;
  In Notin;
  ~ If And Or;
} except {
  ProjectionAccess ArrayAccess Application ? If And Or;
}

----------------------
-- MODEL DEFINITION --
----------------------

type ModelDecl
prod ModelDecl: Decl =
  "model" name:UIdent "=" mc:ModelComposition
  "{"
    (indecl:InModelDecl ",")+
  "}"

-- Below is copied from the syncon file, I don't entirely remember the intended
-- semantics behind all of these.

type ModelComposition {
  grouping = "(" ")",
}

prod ModelAtom: ModelComposition =
  name:LIdent ":" automaton:UIdent
postfix ModelNesting: ModelComposition =
  "(" mc:ModelComposition ")"
prod FastStepAutomatonPre: ModelComposition =
  n:Integer "*"
postfix FastStepAutomatonPost: ModelComposition =
  "*" n:Integer

type InModelDecl

prod InferredFunction: InModelDecl =
  "table" f:LIdent
  "("
    ("," p2:Type ",")*
  ")" (":" ret:Type)?

-- The latter rhs only valid for transition probability
prod Prob: InModelDecl =
  "P" "("
    ( output:"output"
    | initial:"initital"
    | transition:"transition" from:LIdent to:LIdent) ")"
    ( "=" e:Expr
    | /- "="? -- TODO: ll1 -/ "{"
      ("|" automaton:LIdent "=>" e2:Expr)+
      "}"
    )
